{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]"},"docs":[{"location":"","text":"Homemade documentation (Ops oriented) for personal use","title":"HomePage"},{"location":"tags/","text":"Tags Following is a list of relevant tags: bash Start/Stop VM via Api Vmware github Deploy Hugo webpages on Github gohugo Deploy Hugo webpages on Github monitoring Limiter les appels de l'auto discovery Zabbix vwmare Start/Stop VM via Api Vmware zabbix Limiter les appels de l'auto discovery Zabbix","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of relevant tags:","title":"Tags"},{"location":"tags/#bash","text":"Start/Stop VM via Api Vmware","title":"bash"},{"location":"tags/#github","text":"Deploy Hugo webpages on Github","title":"github"},{"location":"tags/#gohugo","text":"Deploy Hugo webpages on Github","title":"gohugo"},{"location":"tags/#monitoring","text":"Limiter les appels de l'auto discovery Zabbix","title":"monitoring"},{"location":"tags/#vwmare","text":"Start/Stop VM via Api Vmware","title":"vwmare"},{"location":"tags/#zabbix","text":"Limiter les appels de l'auto discovery Zabbix","title":"zabbix"},{"location":"Github/hugo_github/","tags":["gohugo","github"],"text":"Pr\u00e9requis Avoir un compte Github Cr\u00e9ation de compte github Installer goHugo sur votre machine locale Installation Hugo Mise en place Cr\u00e9er 2 repo github Stocker le code hugo (repo priv\u00e9 ou publique) H\u00e9berger les fichiers statiques (repo publique uniquement) {{< alert warning >}} Le nom du repo qui h\u00e9bergera le site devra \u00eatre sous la forme: myWebsiteName.github.io qui correspondra par la suite \u00e0 l'url d'acc\u00e8s \u00e0 votre site {{< /alert >}} R\u00e9cup\u00e9rer nos repos en local git clone git@github.com:YourAccountName/YourRepoName.git git clone git@github.com:YourAccountName/myWebsiteName.github.io.git vous pouvez aussi les r\u00e9cup\u00e9rer via https mais les commandes git push [...] vous demanderont un token. Cr\u00e9er un site Hugo Dans votre repo contenant le code (YourRepoName.git) hugo new site myWebsiteName Theme hugo Pour plus de facilit\u00e9 et de rapidit\u00e9, je vous conseille d'utiliser un th\u00e8me maintenu par la communaut\u00e9. R\u00e9f\u00e9rez vous \u00e0 la documentation du theme que vous souhaitez utiliser : themes Git submodule En locale, dans le r\u00e9pertoire principale du site hugo (myWebsiteName) git submodule add -b main https://github.com/YourAccountName/myWebsiteName.github.io.git public Un r\u00e9pertoire nomm\u00e9 public va \u00eatre cr\u00e9\u00e9, tel un lien symbolique vers le repo qui h\u00e9bergera vos fichiers statiques (myWebsiteName.github.io.git). G\u00e9n\u00e9rer les fichiers statiques Hugo Dans le r\u00e9pertoire principe du site hugo (myWebsiteName) hugo -t themeName Les fichiers statiques sont ainsi cr\u00e9\u00e9s dans notre r\u00e9pertoire public. Deployer son site Une fois dans le r\u00e9pertoire public git add . git commit -m \"some commit message\" git push origin main Apr\u00e8s environ 2 minutes (temps de d\u00e9ploiement github variable et consultable via l'url github.com/YourAccountName/myWebsiteName.github.io/deployments/), le site sera maintenant \u00eatre accessible via l'url myWebsiteName.github.io Sauvegarder le reste de son code Dans le r\u00e9pertoire principe du site hugo (myWebsiteName), pousser les modifications comme lors de l'\u00e9tape pr\u00e9c\u00e9dente","title":"Deploy Hugo webpages on Github"},{"location":"Github/hugo_github/#prerequis","text":"Avoir un compte Github Cr\u00e9ation de compte github Installer goHugo sur votre machine locale Installation Hugo","title":"Pr\u00e9requis"},{"location":"Github/hugo_github/#mise-en-place","text":"","title":"Mise en place"},{"location":"Github/hugo_github/#creer-2-repo-github","text":"Stocker le code hugo (repo priv\u00e9 ou publique) H\u00e9berger les fichiers statiques (repo publique uniquement) {{< alert warning >}} Le nom du repo qui h\u00e9bergera le site devra \u00eatre sous la forme: myWebsiteName.github.io qui correspondra par la suite \u00e0 l'url d'acc\u00e8s \u00e0 votre site {{< /alert >}}","title":"Cr\u00e9er 2 repo github"},{"location":"Github/hugo_github/#recuperer-nos-repos-en-local","text":"git clone git@github.com:YourAccountName/YourRepoName.git git clone git@github.com:YourAccountName/myWebsiteName.github.io.git vous pouvez aussi les r\u00e9cup\u00e9rer via https mais les commandes git push [...] vous demanderont un token.","title":"R\u00e9cup\u00e9rer nos repos en local"},{"location":"Github/hugo_github/#creer-un-site-hugo","text":"Dans votre repo contenant le code (YourRepoName.git) hugo new site myWebsiteName","title":"Cr\u00e9er un site Hugo"},{"location":"Github/hugo_github/#theme-hugo","text":"Pour plus de facilit\u00e9 et de rapidit\u00e9, je vous conseille d'utiliser un th\u00e8me maintenu par la communaut\u00e9. R\u00e9f\u00e9rez vous \u00e0 la documentation du theme que vous souhaitez utiliser : themes","title":"Theme hugo"},{"location":"Github/hugo_github/#git-submodule","text":"En locale, dans le r\u00e9pertoire principale du site hugo (myWebsiteName) git submodule add -b main https://github.com/YourAccountName/myWebsiteName.github.io.git public Un r\u00e9pertoire nomm\u00e9 public va \u00eatre cr\u00e9\u00e9, tel un lien symbolique vers le repo qui h\u00e9bergera vos fichiers statiques (myWebsiteName.github.io.git).","title":"Git submodule"},{"location":"Github/hugo_github/#generer-les-fichiers-statiques-hugo","text":"Dans le r\u00e9pertoire principe du site hugo (myWebsiteName) hugo -t themeName Les fichiers statiques sont ainsi cr\u00e9\u00e9s dans notre r\u00e9pertoire public.","title":"G\u00e9n\u00e9rer les fichiers statiques Hugo"},{"location":"Github/hugo_github/#deployer-son-site","text":"Une fois dans le r\u00e9pertoire public git add . git commit -m \"some commit message\" git push origin main Apr\u00e8s environ 2 minutes (temps de d\u00e9ploiement github variable et consultable via l'url github.com/YourAccountName/myWebsiteName.github.io/deployments/), le site sera maintenant \u00eatre accessible via l'url myWebsiteName.github.io","title":"Deployer son site"},{"location":"Github/hugo_github/#sauvegarder-le-reste-de-son-code","text":"Dans le r\u00e9pertoire principe du site hugo (myWebsiteName), pousser les modifications comme lors de l'\u00e9tape pr\u00e9c\u00e9dente","title":"Sauvegarder le reste de son code"},{"location":"Virtualisation/start_stop_vm_api_vmware/","tags":["bash","vwmare"],"text":"Pr\u00e9sentation Dans l'optique d'optimiser les coups dans l'IT(Finops), on peut \u00eatre amen\u00e9 \u00e0 mettre en place un arr\u00eat de l'environnement de qualifications les soirs et weekend par exemple. Afin de pouvoir v\u00e9rifier directement la prise en compte de cette partie, on passera par l'affectation d'un tag sp\u00e9cifique pour l'ensemble des VM que je souhaites int\u00e9grer \u00e0 ce syst\u00e8me. Ils seront alors directement visible dans l'interface graphique de vmware. On partira du postula que l'ensemble des scripts comporte des variables user/password Dans les morceaux de scripts ci-apr\u00e8s, l'option curl k est pr\u00e9sente car mon serveur VMware ne dispose pas de certificat valide Pr\u00e9requis Un utilisateur ou token avec les bons droits d'utilisation de l'api vmware Cr\u00e9er un nouveau tag vmware R\u00e9cup\u00e9r\u00e9 notre tag Une fois votre tag cr\u00e9\u00e9, il faut r\u00e9cup\u00e9rer son ID. ## URL de votre Vcenter vcenter = 'XXXXX.XXXX.XX' ## Creation de votre session \u00e0 l'api Vmware id_session = $( curl -skX POST https:// $vcenter /rest/com/vmware/cis/session -u $( echo $user ) : $( echo $password ) | jq -r .value ) ## Liste des ID tags tags_id = $( curl -skX GET -H \"vmware-api-session-id: $id_session \" -H 'Accept: application/json' https:// $vcenter /rest/com/vmware/cis/tagging/tag | jq -r .value [] ) ## Liste des ID tags avec leur nom ## Si le premier parametre du script est ## - all => on affiche toute la liste ## - le nom de notre nouveau tag => on affiche son ID if [ \" $1 \" == \"all\" ] then for tag in $tags_id do curl -skX GET -H \"vmware-api-session-id: $id_session \" -H 'Accept: application/json' https:// $vcenter /rest/com/vmware/cis/tagging/tag/id: $tag | jq -r '.value | \"tag_name: \\(.name)\\t\\ttag_id: \\(.id)\"' done elif [ \" $1 \" ! = \"\" ] then for tag in $tags_id do curl -skX GET -H \"vmware-api-session-id: $id_session \" -H 'Accept: application/json' https:// $vcenter /rest/com/vmware/cis/tagging/tag/id: $tag | jq -r '.value | \"tag_name: \\(.name)\\t\\ttag_id: \\(.id)\"' | grep -E $1 done fi Ajouter un tag \u00e0 une VM A partir d'ici, on mettra l'ID du nouveau tag dans les scripts. Il se pr\u00e9sente sous la forme : urn:vmomi:InventoryServiceTag:XXXXX-XXXXX-XXXXX:GLOBAL ## URL de votre Vcenter vcenter = 'XXXXX.XXXX.XX' ## Creation de votre session \u00e0 l'api Vmware id_session = $( curl -skX POST https:// $vcenter /rest/com/vmware/cis/session -u $( echo $user ) : $( echo $password ) | jq -r .value ) ## Utilisation de notre tag tag_id = 'urn:vmomi:InventoryServiceTag:XXXXX-XXXXX-XXXXX:GLOBAL' ## Liste des VM \u00e0 downscale \u00e0 partie de leur nom ## On utilisera le pipe comme d\u00e9limiteur vm_a_tag = \"vm1|vm2|vm3\" ## Recuperation des ID de VM vm_name_id = $( curl -skX GET -H \"vmware-api-session-id: $id_session \" -H \"Accept: application/json\" https:// $vcenter /rest/vcenter/vm/ | jq -r '.value[] | \"\\(.name),\\(.vm)\"' | grep -E \" $vm_a_tag \" ) ## Ajout du tag aux VM de la liste for vm in $vm_name_id do vm_id = \" $( echo $vm | cut -d, -f2 ) \" echo \"Ajout du tag \u00e0 la VM $( echo $vm | cut -d, -f1 ) \" curl -skX POST -H \"vmware-api-session-id: $id_session \" -H 'Content-Type: application/json' -d '{\"object_id\": { \"id\": \"' $vm_id '\", \"type\": \"VirtualMachine\"} }' https:// $vcenter /rest/com/vmware/cis/tagging/tag-association/id: { $tag_id } ?~action = attach done pour retirer le tag d'une ou plusieurs VM, remplacer simplement attach par detach dans le script au dessus (dernier appel curl) et relancer le Liste des VM avec le nouveau tag ## URL de votre Vcenter vcenter = 'XXXXX.XXXX.XX' ## Creation de votre session \u00e0 l'api Vmware id_session = $( curl -skX POST https:// $vcenter /rest/com/vmware/cis/session -u $( echo $user ) : $( echo $password ) | jq -r .value ) ## Utilisation de notre tag tag_id = 'urn:vmomi:InventoryServiceTag:XXXXX-XXXXX-XXXXX:GLOBAL' ## Liste des ID des VM avec notre tag vm_tagged = $( curl -skX POST -H \"vmware-api-session-id: $id_session \" -H 'Content-Type: application/json' -d '{\"tag_ids\": [\"' $tag_id '\"]}' https:// $vcenter /rest/com/vmware/cis/tagging/tag-association?~action = list-attached-objects-on-tags | jq -r .value [] .object_ids [] .id ) ## Liste des nom des VM avec notre tag for id_vm in $vm_tagged do vm_name = $( curl -skX GET -H \"vmware-api-session-id: $id_session \" -H \"Accept: application/json\" https:// $vcenter /rest/vcenter/vm/ $id_vm | jq -r .value.name ) echo \" $vm_name ( $id_vm )\" done Allumer/\u00c9teindre les VM avec le tag ## URL de votre Vcenter vcenter = 'XXXXX.XXXX.XX' ## Creation de votre session \u00e0 l'api Vmware id_session = $( curl -skX POST https:// $vcenter /rest/com/vmware/cis/session -u $( echo $user ) : $( echo $password ) | jq -r .value ) ## Utilisation de notre tag tag_id = 'urn:vmomi:InventoryServiceTag:XXXXX-XXXXX-XXXXX:GLOBAL' ## Liste des ID des VM avec notre tag vm_tagged = $( curl -skX POST -H \"vmware-api-session-id: $id_session \" -H 'Content-Type: application/json' -d '{\"tag_ids\": [\"' $tag_id '\"]}' https:// $vcenter /rest/com/vmware/cis/tagging/tag-association?~action = list-attached-objects-on-tags | jq -r .value [] .object_ids [] .id ) ## Si le premier parametre du script est ## - stop => on eteint la VM ## - start => on allume la VM for id_vm in $vm_tagged do if [[ $1 == \"stop\" ]] then curl -skX POST -H \"vmware-api-session-id: $id_session \" -H \"Accept: application/json\" https:// $vcenterr /rest/vcenter/vm/ $id_vm /power/stop fi if [[ $1 == \"upscale\" ]] then curl -skX POST -H \"vmware-api-session-id: $id_session \" -H \"Accept: application/json\" https:// $vcenter /rest/vcenter/vm/ $id_vm /power/start fi if [[ $? -ne 0 ]] then echo \"Error\" fi done Une fois cr\u00e9\u00e9 et test\u00e9, ce script peux \u00eatre mis dans une crontab ou systemd-timer Plus de d\u00e9tails developer.vmware.com","title":"Start/Stop VM via Api Vmware"},{"location":"Virtualisation/start_stop_vm_api_vmware/#presentation","text":"Dans l'optique d'optimiser les coups dans l'IT(Finops), on peut \u00eatre amen\u00e9 \u00e0 mettre en place un arr\u00eat de l'environnement de qualifications les soirs et weekend par exemple. Afin de pouvoir v\u00e9rifier directement la prise en compte de cette partie, on passera par l'affectation d'un tag sp\u00e9cifique pour l'ensemble des VM que je souhaites int\u00e9grer \u00e0 ce syst\u00e8me. Ils seront alors directement visible dans l'interface graphique de vmware. On partira du postula que l'ensemble des scripts comporte des variables user/password Dans les morceaux de scripts ci-apr\u00e8s, l'option curl k est pr\u00e9sente car mon serveur VMware ne dispose pas de certificat valide","title":"Pr\u00e9sentation"},{"location":"Virtualisation/start_stop_vm_api_vmware/#prerequis","text":"Un utilisateur ou token avec les bons droits d'utilisation de l'api vmware Cr\u00e9er un nouveau tag vmware","title":"Pr\u00e9requis"},{"location":"Virtualisation/start_stop_vm_api_vmware/#recupere-notre-tag","text":"Une fois votre tag cr\u00e9\u00e9, il faut r\u00e9cup\u00e9rer son ID. ## URL de votre Vcenter vcenter = 'XXXXX.XXXX.XX' ## Creation de votre session \u00e0 l'api Vmware id_session = $( curl -skX POST https:// $vcenter /rest/com/vmware/cis/session -u $( echo $user ) : $( echo $password ) | jq -r .value ) ## Liste des ID tags tags_id = $( curl -skX GET -H \"vmware-api-session-id: $id_session \" -H 'Accept: application/json' https:// $vcenter /rest/com/vmware/cis/tagging/tag | jq -r .value [] ) ## Liste des ID tags avec leur nom ## Si le premier parametre du script est ## - all => on affiche toute la liste ## - le nom de notre nouveau tag => on affiche son ID if [ \" $1 \" == \"all\" ] then for tag in $tags_id do curl -skX GET -H \"vmware-api-session-id: $id_session \" -H 'Accept: application/json' https:// $vcenter /rest/com/vmware/cis/tagging/tag/id: $tag | jq -r '.value | \"tag_name: \\(.name)\\t\\ttag_id: \\(.id)\"' done elif [ \" $1 \" ! = \"\" ] then for tag in $tags_id do curl -skX GET -H \"vmware-api-session-id: $id_session \" -H 'Accept: application/json' https:// $vcenter /rest/com/vmware/cis/tagging/tag/id: $tag | jq -r '.value | \"tag_name: \\(.name)\\t\\ttag_id: \\(.id)\"' | grep -E $1 done fi","title":"R\u00e9cup\u00e9r\u00e9 notre tag"},{"location":"Virtualisation/start_stop_vm_api_vmware/#ajouter-un-tag-a-une-vm","text":"A partir d'ici, on mettra l'ID du nouveau tag dans les scripts. Il se pr\u00e9sente sous la forme : urn:vmomi:InventoryServiceTag:XXXXX-XXXXX-XXXXX:GLOBAL ## URL de votre Vcenter vcenter = 'XXXXX.XXXX.XX' ## Creation de votre session \u00e0 l'api Vmware id_session = $( curl -skX POST https:// $vcenter /rest/com/vmware/cis/session -u $( echo $user ) : $( echo $password ) | jq -r .value ) ## Utilisation de notre tag tag_id = 'urn:vmomi:InventoryServiceTag:XXXXX-XXXXX-XXXXX:GLOBAL' ## Liste des VM \u00e0 downscale \u00e0 partie de leur nom ## On utilisera le pipe comme d\u00e9limiteur vm_a_tag = \"vm1|vm2|vm3\" ## Recuperation des ID de VM vm_name_id = $( curl -skX GET -H \"vmware-api-session-id: $id_session \" -H \"Accept: application/json\" https:// $vcenter /rest/vcenter/vm/ | jq -r '.value[] | \"\\(.name),\\(.vm)\"' | grep -E \" $vm_a_tag \" ) ## Ajout du tag aux VM de la liste for vm in $vm_name_id do vm_id = \" $( echo $vm | cut -d, -f2 ) \" echo \"Ajout du tag \u00e0 la VM $( echo $vm | cut -d, -f1 ) \" curl -skX POST -H \"vmware-api-session-id: $id_session \" -H 'Content-Type: application/json' -d '{\"object_id\": { \"id\": \"' $vm_id '\", \"type\": \"VirtualMachine\"} }' https:// $vcenter /rest/com/vmware/cis/tagging/tag-association/id: { $tag_id } ?~action = attach done pour retirer le tag d'une ou plusieurs VM, remplacer simplement attach par detach dans le script au dessus (dernier appel curl) et relancer le","title":"Ajouter un tag \u00e0 une VM"},{"location":"Virtualisation/start_stop_vm_api_vmware/#liste-des-vm-avec-le-nouveau-tag","text":"## URL de votre Vcenter vcenter = 'XXXXX.XXXX.XX' ## Creation de votre session \u00e0 l'api Vmware id_session = $( curl -skX POST https:// $vcenter /rest/com/vmware/cis/session -u $( echo $user ) : $( echo $password ) | jq -r .value ) ## Utilisation de notre tag tag_id = 'urn:vmomi:InventoryServiceTag:XXXXX-XXXXX-XXXXX:GLOBAL' ## Liste des ID des VM avec notre tag vm_tagged = $( curl -skX POST -H \"vmware-api-session-id: $id_session \" -H 'Content-Type: application/json' -d '{\"tag_ids\": [\"' $tag_id '\"]}' https:// $vcenter /rest/com/vmware/cis/tagging/tag-association?~action = list-attached-objects-on-tags | jq -r .value [] .object_ids [] .id ) ## Liste des nom des VM avec notre tag for id_vm in $vm_tagged do vm_name = $( curl -skX GET -H \"vmware-api-session-id: $id_session \" -H \"Accept: application/json\" https:// $vcenter /rest/vcenter/vm/ $id_vm | jq -r .value.name ) echo \" $vm_name ( $id_vm )\" done","title":"Liste des VM avec le nouveau tag"},{"location":"Virtualisation/start_stop_vm_api_vmware/#allumereteindre-les-vm-avec-le-tag","text":"## URL de votre Vcenter vcenter = 'XXXXX.XXXX.XX' ## Creation de votre session \u00e0 l'api Vmware id_session = $( curl -skX POST https:// $vcenter /rest/com/vmware/cis/session -u $( echo $user ) : $( echo $password ) | jq -r .value ) ## Utilisation de notre tag tag_id = 'urn:vmomi:InventoryServiceTag:XXXXX-XXXXX-XXXXX:GLOBAL' ## Liste des ID des VM avec notre tag vm_tagged = $( curl -skX POST -H \"vmware-api-session-id: $id_session \" -H 'Content-Type: application/json' -d '{\"tag_ids\": [\"' $tag_id '\"]}' https:// $vcenter /rest/com/vmware/cis/tagging/tag-association?~action = list-attached-objects-on-tags | jq -r .value [] .object_ids [] .id ) ## Si le premier parametre du script est ## - stop => on eteint la VM ## - start => on allume la VM for id_vm in $vm_tagged do if [[ $1 == \"stop\" ]] then curl -skX POST -H \"vmware-api-session-id: $id_session \" -H \"Accept: application/json\" https:// $vcenterr /rest/vcenter/vm/ $id_vm /power/stop fi if [[ $1 == \"upscale\" ]] then curl -skX POST -H \"vmware-api-session-id: $id_session \" -H \"Accept: application/json\" https:// $vcenter /rest/vcenter/vm/ $id_vm /power/start fi if [[ $? -ne 0 ]] then echo \"Error\" fi done Une fois cr\u00e9\u00e9 et test\u00e9, ce script peux \u00eatre mis dans une crontab ou systemd-timer Plus de d\u00e9tails developer.vmware.com","title":"Allumer/\u00c9teindre les VM avec le tag"},{"location":"Zabbix/zabbix_soft_discovery/","tags":["zabbix","monitoring"],"text":"Pr\u00e9sentation Zabbix est un puissant outil de monitoring. La mise en place de l'auto discovery Zabbix est tr\u00e8s pratique afin de r\u00e9cup\u00e9rer des donn\u00e9es remont\u00e9es dynamiquement par des API par exemple. Le probl\u00e8me qui peut survenir lors de sa mise en place est que l'on peut saturer aussi bien le r\u00e9seau, que notre API suivant le nombre de donn\u00e9es que l'on souhaite r\u00e9cup\u00e9rer. Context Nous avons un service rabbitmq qui remonte ces metrics dans un prometheus. Depuis Zabbix, nous voulons mettre en place un auto discovery afin de r\u00e9cup\u00e9rer l'ensemble des messages pr\u00e9sents dans les diff\u00e9rentes queues via le prometheus. Nous passons par de l'auto discovery afin que les futures queues cr\u00e9\u00e9s dans rabbitmq remontent automatiquement dans zabbix (de m\u00eame pour celles qui seront supprim\u00e9es) Mise en place de l'Auto Discovery Depuis notre Host zabbix, dans la partie discovery, nous cr\u00e9ons une \"discovery rule\". Celle-ci nous permettra de r\u00e9cup\u00e9rer l'ensemble des noms des queues pr\u00e9sentes dans le rabbitmq. On lui donne: Un nom Un type => ici \"HTTP agent\" Un cl\u00e9 (key) unique (exemple rabbitmq.autodiscovery.queues) L'Url de notre prometheus (je vous conseil fortement de passer par une Macro zabbix) La query (qui s'ex\u00e9cutera sur le prometheus) => ici on r\u00e9cup\u00e8re les messages des queues rabbitmq Un intervale de mise \u00e0 jour (par d\u00e9faut 1 minutes) Une dur\u00e9e de retention des resources plus pr\u00e9sent (30 jour par d\u00e9faut, diminuer le \u00e0 1 jour) A ce moment, si l'on test notre Discovery rule, on constate que nous avons un retour Json sous la forme: { \"status\" : \"success\" , \"data\" : { \"resultType\" : \"vector\" , \"result\" : [{ \"metric\" : { \"queue\" : \"queue_name1\" } , \"value\" : [ XXXXXXXXXX.XXX, \"1\" ]} , { \"metric\" : { \"queue\" : \"queue_name2\" } , \"value\" : [ XXXXXXXXXX.XXX, \"2\" ]} , { \"metric\" : { \"queue\" : \"queue_name3\" } , \"value\" : [ XXXXXXXXXX.XXX, \"3\" ]}] Les informations qui nous int\u00e9ressent ici sont pr\u00e9sentes dans \"metric\". Nous allons donc les r\u00e9cup\u00e9rer dans le \"Preprocessing\" de notre discovery rule. Nous avons maintenant uniquement queue dans notre retour Json sous la forme: [{ \"queue\" : \"queue_name1\" } , { \"queue\" : \"queue_name2\" } , { \"queue\" : \"queue_name3\" }] Gr\u00e2ce \u00e0 macro de d\u00e9couverte Zabbix (LLD), nous pouvons r\u00e9cup\u00e9rer le noms de chaque queue pr\u00e9sent dans le Path \"queue\". Par la suite, si vous souhaitez ne pas r\u00e9cup\u00e9rer certaines queue ou \u00e0 l'inverse n'en r\u00e9cup\u00e9rer que certaines sp\u00e9cifique, vous pouvez les filtrer Items prototypes \"classique\" L'item prototypes ce base sur la macro LLD r\u00e9cup\u00e9rer par la discovery rule auquel il est associ\u00e9e (pour nous {#QUEUE}). On lui donne: Un nom Un type => ici \"HTTP agent\" Un cl\u00e9 (key) unique gr\u00e2ce \u00e0 la macro LLD (exmple: rabbitmq.items.queue.[{#QUEUE}]) L'Url de notre prometheus La query (qui s'ex\u00e9cutera sur le prometheus) Un intervale de mise \u00e0 jour (par d\u00e9faut 1 minutes) Pour cet item prototype, Type of information => Numeric (unsinged) Notre retour Json sera alors sous la forme: { \"status\" : \"success\" , \"data\" : { \"resultType\" : \"vector\" , \"result\" : [{ \"metric\" : { \"queue\" : \"queue_name1\" } , \"value\" : [ XXXXXXXXXX.XXX, \"1\" ]} , { \"metric\" : { \"queue\" : \"queue_name2\" } , \"value\" : [ XXXXXXXXXX.XXX, \"2\" ]} , { \"metric\" : { \"queue\" : \"queue_name3\" } , \"value\" : [ XXXXXXXXXX.XXX, \"3\" ]}] On passe donc par un nouveau preprocessing afin de r\u00e9cup\u00e9rer uniquement les valeurs qui correspondent au nombre de messages dans nos queues rabbitmq (dans notre exemple, les valeurs sont respectivement 1,2 et 3) Une fois notre configuration sauvegard\u00e9, nos items (ici 3) vont se cr\u00e9er automatiquement avec les noms: - Message in queue: queue_name1 - Message in queue: queue_name2 - Message in queue: queue_name3 Bien que cela soit parfaitement fonctionnelle, il faut bien comprendre que nous effectuons 4 appels au prometheus toutes les minutes. Un appel pour r\u00e9cup\u00e9rer: Le nom de l'ensemble des queues Le nombre de message dans le queue_name1 Le nombre de message dans le queue_name2 Le nombre de message dans le queue_name3 Maintenant si l'on devait r\u00e9cup\u00e9rer le nombre de message sur 1000 queues rabbitmq diff\u00e9rentes, on arriverait \u00e0 1001 req/min. Les performances aussi bien de votre r\u00e9seau que celles de votre prometheus pourraient en \u00eatre fortement impact\u00e9es Optimisation des items prototypes Afin d'optimiser le nombre d'appel des items prototypes, nous allons utiliser les d\u00e9pendances d'items Zabbix. La partie discovery rules ne change pas. Dans un premier temps nous allons cr\u00e9er un item ( non prototypes ). Il fera la m\u00eame requ\u00eate que notre discovery rule. Pour cet item, Type of information => Text Comme ce type d'item peut r\u00e9cup\u00e9rer des donn\u00e9es assez volumineuses, je vous conseil de limiter le stockage de son historique (History storage period) sur 1 jour voir le d\u00e9sactiver Cette fois ci, notre Preprocessing se fera sur l'ensemble de nos valeur dans le Json path data.result Les donn\u00e9es de cet item seront sous la forme: [{ \"metric\" : { \"queue\" : \"queue_name1\" } , \"value\" : [ XXXXXXXXXX.XXX, \"1\" ]} , { \"metric\" : { \"queue\" : \"queue_name2\" } , \"value\" : [ XXXXXXXXXX.XXX, \"2\" ]} , { \"metric\" : { \"queue\" : \"queue_name3\" } , \"value\" : [ XXXXXXXXXX.XXX, \"3\" ]}] Retournons ensuite dans notre discovery rule afin d'y cr\u00e9er un item prototype. Comme pr\u00e9cis\u00e9 en d\u00e9but de section, nous utiliserons de de Type \"Dependent item\" qui fera r\u00e9f\u00e9rence \u00e0 l'item que nous venons de cr\u00e9er. Pour cet item prototype, Type of information => Numeric (unsinged) (DIGITAL \u00e9tant dans cette exemple le nom de mon Host Zabbix) Maintenant que notre item prototypes s'appuis sur les donn\u00e9es r\u00e9cup\u00e9rer par notre item et la macro LLD de notre discovery rule qui r\u00e9cup\u00e8re la liste des nom des queue rabbitmq, il ne nous reste plus qu'\u00e0 faire un dernier preprocessing afin d'avoir les valeurs queue par queue. A l'aide de ce param\u00e9trage, nous avons optimiser notre nombre de requ\u00eates au prometheus afin de r\u00e9cup\u00e9rer le nombre de messages par queue rabbitmq. Vis \u00e0 vis du premier exemple que j'ai nomm\u00e9 \"classique\", nous n'effectuons plus que 2 requ\u00eates quelque soit le cas de figure (1 queue comme 10000 !)","title":"Limiter les appels de l'auto discovery Zabbix"},{"location":"Zabbix/zabbix_soft_discovery/#presentation","text":"Zabbix est un puissant outil de monitoring. La mise en place de l'auto discovery Zabbix est tr\u00e8s pratique afin de r\u00e9cup\u00e9rer des donn\u00e9es remont\u00e9es dynamiquement par des API par exemple. Le probl\u00e8me qui peut survenir lors de sa mise en place est que l'on peut saturer aussi bien le r\u00e9seau, que notre API suivant le nombre de donn\u00e9es que l'on souhaite r\u00e9cup\u00e9rer.","title":"Pr\u00e9sentation"},{"location":"Zabbix/zabbix_soft_discovery/#context","text":"Nous avons un service rabbitmq qui remonte ces metrics dans un prometheus. Depuis Zabbix, nous voulons mettre en place un auto discovery afin de r\u00e9cup\u00e9rer l'ensemble des messages pr\u00e9sents dans les diff\u00e9rentes queues via le prometheus. Nous passons par de l'auto discovery afin que les futures queues cr\u00e9\u00e9s dans rabbitmq remontent automatiquement dans zabbix (de m\u00eame pour celles qui seront supprim\u00e9es)","title":"Context"},{"location":"Zabbix/zabbix_soft_discovery/#mise-en-place-de-lauto-discovery","text":"Depuis notre Host zabbix, dans la partie discovery, nous cr\u00e9ons une \"discovery rule\". Celle-ci nous permettra de r\u00e9cup\u00e9rer l'ensemble des noms des queues pr\u00e9sentes dans le rabbitmq. On lui donne: Un nom Un type => ici \"HTTP agent\" Un cl\u00e9 (key) unique (exemple rabbitmq.autodiscovery.queues) L'Url de notre prometheus (je vous conseil fortement de passer par une Macro zabbix) La query (qui s'ex\u00e9cutera sur le prometheus) => ici on r\u00e9cup\u00e8re les messages des queues rabbitmq Un intervale de mise \u00e0 jour (par d\u00e9faut 1 minutes) Une dur\u00e9e de retention des resources plus pr\u00e9sent (30 jour par d\u00e9faut, diminuer le \u00e0 1 jour) A ce moment, si l'on test notre Discovery rule, on constate que nous avons un retour Json sous la forme: { \"status\" : \"success\" , \"data\" : { \"resultType\" : \"vector\" , \"result\" : [{ \"metric\" : { \"queue\" : \"queue_name1\" } , \"value\" : [ XXXXXXXXXX.XXX, \"1\" ]} , { \"metric\" : { \"queue\" : \"queue_name2\" } , \"value\" : [ XXXXXXXXXX.XXX, \"2\" ]} , { \"metric\" : { \"queue\" : \"queue_name3\" } , \"value\" : [ XXXXXXXXXX.XXX, \"3\" ]}] Les informations qui nous int\u00e9ressent ici sont pr\u00e9sentes dans \"metric\". Nous allons donc les r\u00e9cup\u00e9rer dans le \"Preprocessing\" de notre discovery rule. Nous avons maintenant uniquement queue dans notre retour Json sous la forme: [{ \"queue\" : \"queue_name1\" } , { \"queue\" : \"queue_name2\" } , { \"queue\" : \"queue_name3\" }] Gr\u00e2ce \u00e0 macro de d\u00e9couverte Zabbix (LLD), nous pouvons r\u00e9cup\u00e9rer le noms de chaque queue pr\u00e9sent dans le Path \"queue\". Par la suite, si vous souhaitez ne pas r\u00e9cup\u00e9rer certaines queue ou \u00e0 l'inverse n'en r\u00e9cup\u00e9rer que certaines sp\u00e9cifique, vous pouvez les filtrer","title":"Mise en place de l'Auto Discovery"},{"location":"Zabbix/zabbix_soft_discovery/#items-prototypes-classique","text":"L'item prototypes ce base sur la macro LLD r\u00e9cup\u00e9rer par la discovery rule auquel il est associ\u00e9e (pour nous {#QUEUE}). On lui donne: Un nom Un type => ici \"HTTP agent\" Un cl\u00e9 (key) unique gr\u00e2ce \u00e0 la macro LLD (exmple: rabbitmq.items.queue.[{#QUEUE}]) L'Url de notre prometheus La query (qui s'ex\u00e9cutera sur le prometheus) Un intervale de mise \u00e0 jour (par d\u00e9faut 1 minutes) Pour cet item prototype, Type of information => Numeric (unsinged) Notre retour Json sera alors sous la forme: { \"status\" : \"success\" , \"data\" : { \"resultType\" : \"vector\" , \"result\" : [{ \"metric\" : { \"queue\" : \"queue_name1\" } , \"value\" : [ XXXXXXXXXX.XXX, \"1\" ]} , { \"metric\" : { \"queue\" : \"queue_name2\" } , \"value\" : [ XXXXXXXXXX.XXX, \"2\" ]} , { \"metric\" : { \"queue\" : \"queue_name3\" } , \"value\" : [ XXXXXXXXXX.XXX, \"3\" ]}] On passe donc par un nouveau preprocessing afin de r\u00e9cup\u00e9rer uniquement les valeurs qui correspondent au nombre de messages dans nos queues rabbitmq (dans notre exemple, les valeurs sont respectivement 1,2 et 3) Une fois notre configuration sauvegard\u00e9, nos items (ici 3) vont se cr\u00e9er automatiquement avec les noms: - Message in queue: queue_name1 - Message in queue: queue_name2 - Message in queue: queue_name3 Bien que cela soit parfaitement fonctionnelle, il faut bien comprendre que nous effectuons 4 appels au prometheus toutes les minutes. Un appel pour r\u00e9cup\u00e9rer: Le nom de l'ensemble des queues Le nombre de message dans le queue_name1 Le nombre de message dans le queue_name2 Le nombre de message dans le queue_name3 Maintenant si l'on devait r\u00e9cup\u00e9rer le nombre de message sur 1000 queues rabbitmq diff\u00e9rentes, on arriverait \u00e0 1001 req/min. Les performances aussi bien de votre r\u00e9seau que celles de votre prometheus pourraient en \u00eatre fortement impact\u00e9es","title":"Items prototypes \"classique\""},{"location":"Zabbix/zabbix_soft_discovery/#optimisation-des-items-prototypes","text":"Afin d'optimiser le nombre d'appel des items prototypes, nous allons utiliser les d\u00e9pendances d'items Zabbix. La partie discovery rules ne change pas. Dans un premier temps nous allons cr\u00e9er un item ( non prototypes ). Il fera la m\u00eame requ\u00eate que notre discovery rule. Pour cet item, Type of information => Text Comme ce type d'item peut r\u00e9cup\u00e9rer des donn\u00e9es assez volumineuses, je vous conseil de limiter le stockage de son historique (History storage period) sur 1 jour voir le d\u00e9sactiver Cette fois ci, notre Preprocessing se fera sur l'ensemble de nos valeur dans le Json path data.result Les donn\u00e9es de cet item seront sous la forme: [{ \"metric\" : { \"queue\" : \"queue_name1\" } , \"value\" : [ XXXXXXXXXX.XXX, \"1\" ]} , { \"metric\" : { \"queue\" : \"queue_name2\" } , \"value\" : [ XXXXXXXXXX.XXX, \"2\" ]} , { \"metric\" : { \"queue\" : \"queue_name3\" } , \"value\" : [ XXXXXXXXXX.XXX, \"3\" ]}] Retournons ensuite dans notre discovery rule afin d'y cr\u00e9er un item prototype. Comme pr\u00e9cis\u00e9 en d\u00e9but de section, nous utiliserons de de Type \"Dependent item\" qui fera r\u00e9f\u00e9rence \u00e0 l'item que nous venons de cr\u00e9er. Pour cet item prototype, Type of information => Numeric (unsinged) (DIGITAL \u00e9tant dans cette exemple le nom de mon Host Zabbix) Maintenant que notre item prototypes s'appuis sur les donn\u00e9es r\u00e9cup\u00e9rer par notre item et la macro LLD de notre discovery rule qui r\u00e9cup\u00e8re la liste des nom des queue rabbitmq, il ne nous reste plus qu'\u00e0 faire un dernier preprocessing afin d'avoir les valeurs queue par queue. A l'aide de ce param\u00e9trage, nous avons optimiser notre nombre de requ\u00eates au prometheus afin de r\u00e9cup\u00e9rer le nombre de messages par queue rabbitmq. Vis \u00e0 vis du premier exemple que j'ai nomm\u00e9 \"classique\", nous n'effectuons plus que 2 requ\u00eates quelque soit le cas de figure (1 queue comme 10000 !)","title":"Optimisation des items prototypes"},{"location":"tags/","text":"Tags Following is a list of relevant tags: bash Start/Stop VM via Api Vmware github Deploy Hugo webpages on Github gohugo Deploy Hugo webpages on Github monitoring Limiter les appels de l'auto discovery Zabbix vwmare Start/Stop VM via Api Vmware zabbix Limiter les appels de l'auto discovery Zabbix","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of relevant tags:","title":"Tags"},{"location":"tags/#bash","text":"Start/Stop VM via Api Vmware","title":"bash"},{"location":"tags/#github","text":"Deploy Hugo webpages on Github","title":"github"},{"location":"tags/#gohugo","text":"Deploy Hugo webpages on Github","title":"gohugo"},{"location":"tags/#monitoring","text":"Limiter les appels de l'auto discovery Zabbix","title":"monitoring"},{"location":"tags/#vwmare","text":"Start/Stop VM via Api Vmware","title":"vwmare"},{"location":"tags/#zabbix","text":"Limiter les appels de l'auto discovery Zabbix","title":"zabbix"}]}